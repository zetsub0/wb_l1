1.
```text
strings.Builder
```

2.
```text
Тип данных, который описывает методы, присущие какому-либо объекту
```

3.
```text
В отличии от mutex, rwmutex допускает конкурентную запись
```

4.
```text
У буфферизированного канала может быть вместимость. 
Если в небуферизированный канал идет запись, 
то обязательно где то должно быть чтение.
```

5.
```text
0
```

6.
```text
Нет.
```

7.
```text
Если принтануть всю мапу через fmt.print(), то выведется в упорядоченном по ключам виде. 
Если проитерироваться по мапе, то порядок будет случайный.
```

8.
```text
Make инициализирует переменную, 
New аллоцирует память и возвращает указатель на эту переменную
```

9.
```text
                        slice
1. x := make([]int)
2. x := []int{}
не уверен, можно ли сказать что создается слайс
3. var x []int
4. f := *new([]int)
                        map
1. x := make(map[int]int)
2. z := map[int]int{}
не уверен, можно ли сказать что создается мапа
3. u = map[int]int{}
4. f := *new(map[int]int)
```

10.
```text
1 1
В функции update, когда p берет адрес b, создается новая переменная p, 
которая акутальна только в скоупе функции update.
```

11.
```text
Вывод будет рандомный из чисел 0, 1, 2, 3, 4 => deadlock
Вейтгруппа передается не по ссылке, а по значению => счетчик не уменьшается
```

12.
```text
0. В конструкции if при инициализации n создается локальный скоуп. 
"Declaration of 'n' shadows declaration at main.go"
```

13.
```text
[100, 2, 3, 4, 5]
Такой вывод обусловлен внутренним устройством слайса.
До тех пор пока не меняется "cap" слайса, по факту мы работаем с одной областью
памяти. Но как только мы использовали append и превысили "cap", 
для слайса v создался новый базовый массив. 
И дальнейшие изменения остались в скоупе функции.
```

14.
```text
[b b a][a a]
Первый вывод будет внутри функции. Второй внутри main.
Изменения не произошли т.к. при append был увеличен "cap".
Следовательно slice в функции уже не имеет ничего общего со
slice в main.
```
